/**
 * 
 */
package pages;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.HashMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * @author tunder
 *
 */
public class EnsembleOutput implements Runnable {
	
	private String outputDir;
	private BlockingQueue<Unknown> inQueue;
	private int numVolumes;
	private int numModels;
	private ArrayList<String> modelNames;
	private ArrayList<String> genreLabels;
	private int numGenres;
	private HashMap<String, Integer> genreIndex;
	
	public EnsembleOutput(String outputDir, BlockingQueue<Unknown> inQueue, int numVolumes, int numModels, 
			ArrayList<String> modelNames, ArrayList<String> genreLabels, HashMap<String, Integer> genreIndex) {
		this.outputDir = outputDir;
		this.inQueue = inQueue;
		this.numVolumes = numVolumes;
		this.numModels = numModels;
		this.modelNames = modelNames;
		this.genreLabels = genreLabels;
		numGenres = genreLabels.size();
		this.genreIndex = genreIndex;
	}
	
	@Override
	public void run() {
		
		for (int i = 0; i < numVolumes; ++i) {
			try {
				Unknown volume = inQueue.poll(10, TimeUnit.MINUTES);
				
				// We need to check that this volume has a result associated with each model.
				// Otherwise don't print anything.
				int numResults = volume.getNumResults();
				if (numResults == numModels) {
					int numPoints = volume.getNumPoints();
					String thisFile = volume.getLabel();
					String outFile = thisFile + ".predict";
					String outPath = outputDir + "/" + outFile;
					
					for (int j = 0; j < numModels; ++j) {
						String name = modelNames.get(j);
						JSONResultWriter writer = new JSONResultWriter(outPath, name, genreLabels);
						writer.writeJSON(numPoints, thisFile, volume.getRaw(j), volume.getSmooth(j));
					}
				
					ClassificationResult consensus = reconcilePredictions(volume.rawResults, volume.smoothResults, numPoints);
					JSONResultWriter writer = new JSONResultWriter(outPath, "ensemble", genreLabels);
					writer.writeConsensus(thisFile, consensus, numPoints);
				}
				volume = null;
				// Here we are freeing up the object at the end of the assembly line to avoid
				// a possible memory leak.
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
		}
		System.out.println("Terminated output loop.");
	}
	
	private ClassificationResult reconcilePredictions(ArrayList<ClassificationResult> rawResults, 
			ArrayList<ClassificationResult> smoothedResults, int numPoints) {
		
		// One strategy for combining ensembles is to average their predicted probabilities
		// for each genre. In practice, simple voting is often more reliable, and we
		// use that as our main strategy. But averaging probabilities is useful
		// for other purposes. It gives us probabilistic output, and we use it to generate
		// tiebreakers in the voting process. We only use smoothed probabilities here.
		
		ArrayList<double[]> averagePredictions = new ArrayList<double[]>(numPoints);
		ArrayList<String> meanGenres = new ArrayList<String>(numPoints);
		
		for (int i = 0; i < numPoints; ++i) {
			double[] thisPage = new double[numGenres];
			Arrays.fill(thisPage, 0d);
			for (int j = 0; j < numModels; ++j) {
				double[] thisPrediction = smoothedResults.get(j).probabilities.get(i);
				// That's a list of genre probabilities for page i produced by model j.
				thisPrediction = normalize(thisPrediction);
				// Sum all predictions for this page.
				for (int k = 0; k < numGenres; ++ k) {
					thisPage[k] += thisPrediction[k];
				}
			}
			thisPage = normalize(thisPage);
			String topGenreByAveraging = maxgenre(thisPage);
			averagePredictions.add(thisPage);
			meanGenres.add(topGenreByAveraging);
		}
		
		// Now for the voting. We allow both rough and smooth models to vote. The smoothed
		// are ultimately preferred, since they've generated the tiebreakers.
		
		ArrayList<String> consensus = new ArrayList<String>(numPoints);
		ArrayList<Double> dissents = new ArrayList<Double>(numPoints);
		
		for (int i = 0; i < numPoints; ++i) {
			int[] theseVotes = new int[numGenres];
			Arrays.fill(theseVotes, 0);
			for (int j = 0; j < numModels; ++j) {
				String roughPrediction = rawResults.get(j).predictions.get(i);
				String smoothPrediction = smoothedResults.get(j).predictions.get(i);
				addVote(theseVotes, roughPrediction);
				addVote(theseVotes, smoothPrediction);
			}
			Pair electionResult = runElection(theseVotes, meanGenres.get(i));
			// the second argument of runElection is a tiebreaker vote generated by numeric
			// averaging of smoothed predictions.	
			consensus.add((String) electionResult.getFirst());
			// The first part of the pair is the consensus result.
			dissents.add((Double) electionResult.getSecond());
			// And the second part reports the level of dissent in that vote.
		}
		
		ClassificationResult consensusResult = new ClassificationResult(averagePredictions, consensus, numGenres, dissents);
		return consensusResult;
	}
	
	private double[] normalize(double[] input) {
		double total = 0d;
		for (double element : input) {
			total += element;
		}
		for (int i = 0; i < input.length; ++ i) {
			input[i] = input[i] / total;
		}
		return input;
	}
	
	private String maxgenre(double[] predictions) {
		String theGenre = "error";
		double max = 0d;
		for (int i = 0; i < numGenres; ++i) {
			if (predictions[i] > max) {
				max = predictions[i];
				theGenre = genreLabels.get(i);
			}
		}
		return theGenre;
	}
	
	private String maxvote(int[] votes) {
		// This assumes there are no ties!
		String theGenre = "error";
		int max = 0;
		for (int i = 0; i < numGenres; ++i) {
			if (votes[i] > max) {
				max = votes[i];
				theGenre = genreLabels.get(i);
			}
		}
		return theGenre;
	}
	
	private void addVote(int[] votes, String aGenre) {
		int idx = genreIndex.get(aGenre);
		votes[idx] += 1;
	}
	
	private Pair runElection(int[] votes, String tiebreaker) {
		int electorate = 0;
		for (int votesInCategory : votes) {
			electorate += votesInCategory;
		}
		int[] sortedvotes = votes.clone();
		Arrays.sort(sortedvotes);
		// This sorted list won't tell us which genre is highest, but it
		// does tell us whether we have a tie or not. Also it tells us
		
		double dissent = (electorate - sortedvotes[numGenres - 1]) / (double) electorate;
		
		if (sortedvotes[numGenres - 1] > sortedvotes[numGenres - 2]) {
			// We have a clear winner. No tiebreaking necessary.
			return new Pair(maxvote(votes), dissent);
		}
		
		else {
			addVote(votes, tiebreaker);
			sortedvotes = votes.clone();
			Arrays.sort(sortedvotes);
			
			if (sortedvotes[numGenres - 1] > sortedvotes[numGenres - 2]) {
				// Tiebreaking has produced a winner.
				return new Pair(maxvote(votes), dissent);
			}
			else {
				return new Pair(resolveTie(votes), dissent);
			}
		}
	}
	
	private String resolveTie(int[] votes) {
		String[] contenders = new String[2];
		Arrays.fill(contenders, "error");
		int max = 0;
		int secondmax = 0;
		for (int i = 0; i < numGenres; ++i) {
			if (votes[i] >= max) {
				secondmax = max;
				max = votes[i];
				contenders[1] = contenders[0];
				contenders[0] = genreLabels.get(i);
			}
			else if (votes[i] >= secondmax) {
				secondmax = votes[i];
				contenders[1] = genreLabels.get(i);
			}
		}
		
		return contenders[new Random().nextInt(2)];
	}

}
